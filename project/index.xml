<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Project | Complexity Methods for Behavioural Science</title>
    <link>/project/</link>
      <atom:link href="/project/index.xml" rel="self" type="application/rss+xml" />
    <description>Project</description>
    <generator>Wowchemy (https://wowchemy.com)</generator><language>en-us</language><copyright>©2022</copyright>
    <image>
      <url>/images/icon_hu0b7a4cb9992c9ac0e91bd28ffd38dd00_9727_512x512_fill_lanczos_center_3.png</url>
      <title>Project</title>
      <link>/project/</link>
    </image>
    
    <item>
      <title>COVID19</title>
      <link>/project/covid19/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>/project/covid19/</guid>
      <description>


&lt;div id=&#34;non-linear-growth-processes&#34; class=&#34;section level1&#34;&gt;
&lt;h1&gt;&lt;strong&gt;Non-linear Growth processes&lt;/strong&gt;&lt;/h1&gt;
&lt;p&gt;Media are filled with talk about about exponential growth due to the COVID-19 outbreak. This page is a brief introduction to the mathematics of change, most of the text and examples are copied from courses I teach on dynamics of complex systems &lt;a href=&#34;https://www.ru.nl/courseguides/socsci/courses-osiris/bs/sow-bs044-dynamics-complex-systems/&#34;&gt;Research Master Behavioural Science&lt;/a&gt; and the &lt;a href=&#34;https://www.ru.nl/radboudsummerschool/courses/cancellation-2020-edition/&#34;&gt;Radboud Summerschool: Complexity Methods for Behavioural Science&lt;/a&gt;. The summerschool been cancelled this year. So, I thought I might as well take some time to discuss some of the course topics that are relevant for understanding some of the (interpretations of the) data on the consequences of the current pandemic of the disease COVID-19, caused by the virus &lt;a href=&#34;https://youtu.be/5DGwOJXSxqg&#34;&gt;SARS-CoV-2&lt;/a&gt;.&lt;/p&gt;
&lt;p&gt;Despite the claims made by some behavioural scientists….&lt;/p&gt;
&lt;blockquote class=&#34;twitter-tweet&#34;&gt;
&lt;p lang=&#34;tl&#34; dir=&#34;ltr&#34;&gt;
Hahahahahahahahahahahahahahahahahahahahahahahahahahahahahahahahahahahahahahahahahahahahahahahahahahahahahahahahahahahahahahahahahahahahahahahahahahahahahahahahahahahahahahahahahahahahahahahahahahahahahahah… “I have a PhD in social science”… hahahahaha&lt;a href=&#34;https://t.co/yWQrz8qnpY&#34;&gt;https://t.co/yWQrz8qnpY&lt;/a&gt; &lt;a href=&#34;https://t.co/RttCXiR3DL&#34;&gt;https://t.co/RttCXiR3DL&lt;/a&gt;
&lt;/p&gt;
— Fred Hasselman (&lt;span class=&#34;citation&#34;&gt;@FredHasselman&lt;/span&gt;) &lt;a href=&#34;https://twitter.com/FredHasselman/status/1247205820565250051?ref_src=twsrc%5Etfw&#34;&gt;April 6, 2020&lt;/a&gt;
&lt;/blockquote&gt;
&lt;script async src=&#34;https://platform.twitter.com/widgets.js&#34; charset=&#34;utf-8&#34;&gt;&lt;/script&gt;
&lt;p&gt;…studying formal models of change processes and spreading of disease in social networks is not part of the standard analytical toolbox of the behavioural sciences including psychological science.&lt;/p&gt;
&lt;p&gt;

&lt;div class=&#34;alert alert-warning&#34;&gt;
  &lt;div&gt;
    DISCLAIMER: I am not a medical doctor, epidemiologist or statistician. Yes, I do have a PhD in social science. The examples on this page are demonstrations of working with analytical solutions of differential equations and fitting them to data, they are not recommendations or claims about what will happen in the coming months. The data, however, are real. They represent people who are currently very ill, or who have sadly succumbed to the disease.
  &lt;/div&gt;
&lt;/div&gt;
&lt;/p&gt;
&lt;div id=&#34;mathematics-of-change&#34; class=&#34;section level2&#34;&gt;
&lt;h2&gt;Mathematics of Change&lt;/h2&gt;
&lt;p&gt;Change processes describe how a variable changes as a function of time. There are two ‘flavours’ of time: Discrete time (or metronome time) and continuous time. The associated formal description takes the form of &lt;em&gt;difference equations&lt;/em&gt; (or maps) for discrete time and &lt;em&gt;differential equations&lt;/em&gt; (of flows) for continuous time.&lt;/p&gt;
&lt;p&gt;The notation of how a variable &lt;span class=&#34;math inline&#34;&gt;\(Y\)&lt;/span&gt; &lt;em&gt;changes over time&lt;/em&gt; is different for each flavour of time. We’ll start with one of the simplest growth processes, &lt;em&gt;linear growth&lt;/em&gt; in discrete time, for example, the interest you get when you put money in a savings account. The money you get after some period of time is proportional to what you started out with (the initial condition, &lt;span class=&#34;math inline&#34;&gt;\(Y_{i=0}\)&lt;/span&gt;), and the interest rate &lt;span class=&#34;math inline&#34;&gt;\(r\)&lt;/span&gt;. Putting those components together produces the difference equation known as the &lt;em&gt;linear map&lt;/em&gt;:&lt;/p&gt;
&lt;p&gt;&lt;span class=&#34;math display&#34;&gt;\[
Y_{i+1} = r*Y_i
\]&lt;/span&gt;
The index &lt;span class=&#34;math inline&#34;&gt;\(i\)&lt;/span&gt; is often used (instead of &lt;span class=&#34;math inline&#34;&gt;\(t\)&lt;/span&gt;) to indicate we are using discrete steps of time &lt;a href=&#34;#fn1&#34; class=&#34;footnote-ref&#34; id=&#34;fnref1&#34;&gt;&lt;sup&gt;1&lt;/sup&gt;&lt;/a&gt;. The equation translates to: “The value of &lt;span class=&#34;math inline&#34;&gt;\(Y\)&lt;/span&gt;, one step of time into the future, is equal to the value of &lt;span class=&#34;math inline&#34;&gt;\(Y\)&lt;/span&gt; right now (&lt;span class=&#34;math inline&#34;&gt;\(i\)&lt;/span&gt;), times the value of &lt;span class=&#34;math inline&#34;&gt;\(r\)&lt;/span&gt;”. So, if I start out with &lt;span class=&#34;math inline&#34;&gt;\(Y_{i=0} = 10\)&lt;/span&gt; Euros at an interest rate of &lt;span class=&#34;math inline&#34;&gt;\(r = 1.1\)&lt;/span&gt; and wait &lt;span class=&#34;math inline&#34;&gt;\(6\)&lt;/span&gt; months, we can &lt;em&gt;iterate&lt;/em&gt; the function to see how much money I end up with:&lt;/p&gt;
&lt;p&gt;&lt;span class=&#34;math display&#34;&gt;\[
\begin{align}
Y_{0} &amp;amp;= 10 \\
Y_{1} &amp;amp;= 1.1 * 10\ \ \ \ \ \ \ \ \ = 11 \\
Y_{2} &amp;amp;= 1.1 * 11\ \ \ \ \ \ \ \ \ = 12.1 \\
Y_{3} &amp;amp;= 1.1 * 12.1\ \ \ \ \ \ = 13.31 \\
Y_{4} &amp;amp;= 1.1 * 13.31\ \ \ \ = 14.641 \\
Y_{5} &amp;amp;= 1.1 * 14.641\ \ = 16.1051 \\
Y_{6} &amp;amp;= 1.1 * 16.1051 = 17.71561 \\
\end{align}
\]&lt;/span&gt;&lt;/p&gt;
&lt;div id=&#34;numerical-solutions&#34; class=&#34;section level3&#34;&gt;
&lt;h3&gt;Numerical Solutions&lt;/h3&gt;
&lt;p&gt;Let’s make a plot of this process in R and increase the number of iterations to 12 months:&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;Y0    &amp;lt;- 10
r     &amp;lt;- 1.1
Niter &amp;lt;- 12
Y     &amp;lt;- c(Y0, rep(NA,Niter-1))

# Iteration
for(i in 1:(Niter-1)){
  Y[i+1] &amp;lt;- r*Y[i]
}

plot(x = 1:Niter, y = Y, type = &amp;quot;b&amp;quot;, ylim = c(0,40))&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;img src=&#34;/project/COVID19/index_files/figure-html/interest-1.png&#34; width=&#34;672&#34; /&gt;&lt;/p&gt;
&lt;p&gt;This iteration is called a &lt;em&gt;numerical solution&lt;/em&gt;, because we have to actually calulate the value of &lt;span class=&#34;math inline&#34;&gt;\(Y\)&lt;/span&gt; at each step of the iteration. For a very limited number of difference and differential equations, there is an &lt;em&gt;analytical solution&lt;/em&gt; of the process, which allows you to get to the value of &lt;em&gt;Y&lt;/em&gt; at any given point in time, for any given value of parameters and initial conditions.&lt;/p&gt;
&lt;/div&gt;
&lt;div id=&#34;analytical-solutions&#34; class=&#34;section level3&#34;&gt;
&lt;h3&gt;Analytical solutions&lt;/h3&gt;
&lt;p&gt;Remember that the analytical solution for the logistic equation is:&lt;/p&gt;
&lt;p&gt;&lt;span class=&#34;math display&#34;&gt;\[
Y(t)  =  \frac{K * Y_0}{Y_0 + \left(K - Y_0 \right) * e^{-r*t} }
\]&lt;/span&gt;
This can be ‘simplified’ to&lt;/p&gt;
&lt;p&gt;&lt;span class=&#34;math display&#34;&gt;\[
Y(t)  =  \frac{K}{1 + \left(\frac{K}{Y_0-1} \right) * e^{-r*t} }
\]&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;If we want to know the growth level &lt;span class=&#34;math inline&#34;&gt;\(Y_t\)&lt;/span&gt; at &lt;span class=&#34;math inline&#34;&gt;\(t=10\)&lt;/span&gt;, with &lt;span class=&#34;math inline&#34;&gt;\(Y_0=.0001\)&lt;/span&gt;, &lt;span class=&#34;math inline&#34;&gt;\(r=1.1\)&lt;/span&gt; and &lt;span class=&#34;math inline&#34;&gt;\(K=4\)&lt;/span&gt;, we can just &lt;code&gt;fill it in&lt;/code&gt;:&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;# Define a function for the solution
logSol &amp;lt;- function(Y0, r, K, t){K/(1+(K/Y0-1)*exp(-r*t))}

# Call the function
logSol(Y0=.0001, r=1.1, K=4, t=10)&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;## [1] 2.398008&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;We can pass a vector of time points to create the exact solution, the same we would get if we were to iterate the differential/difference equation.&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;# Plot from t=1 to t=100
plot(logSol(Y0=.0001, r=1.1, K=4, t=seq(1,20)), type = &amp;quot;b&amp;quot;, 
     ylab = expression(Y[t]), xlab = &amp;quot;t&amp;quot;)
# Plot t=10 in red
points(10,logSol(Y0=.0001, r=1.1, K=4, t=10), col=&amp;quot;red&amp;quot;, pch=16)&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;img src=&#34;/project/COVID19/index_files/figure-html/unnamed-chunk-2-1.png&#34; width=&#34;672&#34; /&gt;&lt;/p&gt;
&lt;/div&gt;
&lt;div id=&#34;numerical-solution-discrete&#34; class=&#34;section level3 unnumbered&#34;&gt;
&lt;h3&gt;Numerical solution (discrete)&lt;/h3&gt;
&lt;p&gt;If we would iterate the differential equation …&lt;/p&gt;
&lt;p&gt;&lt;span class=&#34;math display&#34;&gt;\[
\frac{dY}{dt} = Y_t * (1 + r - r * \frac{Y_t}{K})
\]&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;… as if it were a difference equation, we are &lt;em&gt;not&lt;/em&gt; simulating continuous time, but a discrete time version of the model:&lt;/p&gt;
&lt;p&gt;&lt;span class=&#34;math display&#34;&gt;\[
Y_{i+1} = Y_i * (1 + r - r * \frac{Y_i}{K})
\]&lt;/span&gt;&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;logIter &amp;lt;-  function(Y0,r,K,t){
  N &amp;lt;- length(t)
  Y &amp;lt;- as.numeric(c(Y0, rep(NA,N-2)))
  sapply(seq_along(Y), function(t){ Y[[t+1]] &amp;lt;&amp;lt;- Y[t] * (1 + r - r * Y[t] / K)})
  }

# Plot from t=1 to t=100
plot(logIter(Y0=.0001, r=1.1, K=4, t=seq(1,20)), type = &amp;quot;b&amp;quot;, 
     ylab = expression(Y[t]), xlab = &amp;quot;t&amp;quot;)
# Plot t=10 in red
points(10,logSol(Y0=.0001, r=1.1, K=4, t=10), col=&amp;quot;red&amp;quot;, pch=16)&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;img src=&#34;/project/COVID19/index_files/figure-html/unnamed-chunk-3-1.png&#34; width=&#34;672&#34; /&gt;&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div id=&#34;fitting-parameters-of-analytic-solutions-to-differential-equations&#34; class=&#34;section level1&#34;&gt;
&lt;h1&gt;&lt;strong&gt;Fitting Parameters of Analytic Solutions to differential Equations&lt;/strong&gt;&lt;/h1&gt;
&lt;div id=&#34;fitting-the-logistic-growth-model-in-spss&#34; class=&#34;section level3 tabset tabset-fade tabset-pills&#34;&gt;
&lt;h3&gt;Fitting the Logistic Growth model in SPSS&lt;/h3&gt;
&lt;p&gt;Open the file &lt;a href=&#34;https://github.com/FredHasselman/The-Complex-Systems-Approach-Book/blob/master/assignments/assignment_data/BasicTSA_nonlinreg/GrowthRegression.sav&#34;&gt;Growthregression.sav&lt;/a&gt;, it contains two variables: &lt;code&gt;Time&lt;/code&gt; and &lt;code&gt;Y(t)&lt;/code&gt;.&lt;/p&gt;
&lt;p&gt;This is data from an iteration of the logistic growth differential equation you are familiar with by now, but let’s pretend it’s data from one subject measured on 100 occasions.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Plot Y(t) against Time Recognize the shape?&lt;/li&gt;
&lt;li&gt;To get the growth parameter we’ll try to fit the solution of the logistic flow with SPSS non-linear regression
&lt;ul&gt;
&lt;li&gt;Select non-linear… from the &lt;code&gt;Analysis&lt;/code&gt; &amp;gt;&amp;gt; &lt;code&gt;Regression&lt;/code&gt; menu.&lt;/li&gt;
&lt;li&gt;Here we can build the solution equation. We need three parameters:
a. &lt;strong&gt;Yzero&lt;/strong&gt;, the initial condition.
b. &lt;em&gt;K&lt;/em&gt;, the carrying capacity.
c. &lt;em&gt;r&lt;/em&gt;, the growth rate.&lt;/li&gt;
&lt;li&gt;Fill these in where it says &lt;code&gt;parameters&lt;/code&gt; give all parameters a starting value of &lt;span class=&#34;math inline&#34;&gt;\(0.01\)&lt;/span&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Take a good look at the analytic solution of the (stylized) logistic flow:&lt;/p&gt;
&lt;p&gt;&lt;span class=&#34;math display&#34;&gt;\[
Y(t)  =  \frac{K * Y_0}{Y_0 + \left(K-Y_{0}\right) * e^{-r*t} }
\]&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;Try to build this equation, the function for &lt;span class=&#34;math inline&#34;&gt;\(e\)&lt;/span&gt; is called &lt;code&gt;EXP&lt;/code&gt; in &lt;code&gt;SPSS&lt;/code&gt; (&lt;code&gt;Function Group&lt;/code&gt; &amp;gt;&amp;gt; &lt;code&gt;Arithmetic&lt;/code&gt;)
Group terms by using parentheses as shown in the equation.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;If you think you have built the model correctly, click on &lt;code&gt;Save&lt;/code&gt; choose &lt;code&gt;predicted values&lt;/code&gt;. Then paste your syntax and run it!
&lt;ul&gt;
&lt;li&gt;Check the estimated parameter values.&lt;/li&gt;
&lt;li&gt;Check &lt;span class=&#34;math inline&#34;&gt;\(R^2\)&lt;/span&gt;!!!&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;Plot a line graph of both the original data and the predicted values. (Smile)&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;You can try do the same using a polynomial approach.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;A polynomial fishing expedition:
&lt;ul&gt;
&lt;li&gt;Create time-varying ‘covariates’ of &lt;span class=&#34;math inline&#34;&gt;\(Y(t)\)&lt;/span&gt;:&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code&gt;COMPUTE T1=Yt * Time.
COMPUTE T2=Yt * (Time ** 2). 
COMPUTE T3=Yt * (Time ** 3). 
COMPUTE T4=Yt * (Time ** 4). 
EXECUTE.&lt;/code&gt;&lt;/pre&gt;
&lt;ul&gt;
&lt;li&gt;Use these variables as predictors of &lt;span class=&#34;math inline&#34;&gt;\(Y(t)\)&lt;/span&gt; in a regular linear regression analysis. This is called a &lt;em&gt;polynomial regression&lt;/em&gt;: Fitting combinations of curves of different shapes on the data.&lt;/li&gt;
&lt;li&gt;Before you run the analysis: Click &lt;code&gt;Save&lt;/code&gt; Choose &lt;code&gt;Predicted Values: Unstandardized&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;div class=&#34;rmdselfthink&#34;&gt;
&lt;p&gt;Look at &lt;span class=&#34;math inline&#34;&gt;\(R^2\)&lt;/span&gt;. This is also almost 1!&lt;/p&gt;
&lt;p&gt;Which model is better?&lt;/p&gt;
Think about this: Based on the results of the linear regression what can you tell about the &lt;em&gt;growth rate&lt;/em&gt;, the &lt;em&gt;carrying capacity&lt;/em&gt; or the &lt;em&gt;initial condition&lt;/em&gt;?
&lt;/div&gt;

&lt;ul&gt;
&lt;li&gt;Create a line graph of &lt;span class=&#34;math inline&#34;&gt;\(Y(t)\)&lt;/span&gt;, plot the predicted values of the non-linear regression and the unstandardised predicted values of the linear polynomial regression against &lt;code&gt;time&lt;/code&gt; in one figure.
&lt;ul&gt;
&lt;li&gt;Now you can see that the shape is approximated by the polynomials, but it is not quite the same. Is this really a model of a growth process as we could encounter it in nature?&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/div&gt;
&lt;div id=&#34;fitting-the-logistic-growth-model-in-r&#34; class=&#34;section level3 tabset tabset-fade tabset-pills&#34;&gt;
&lt;h3&gt;Fitting the Logistic Growth model in R&lt;/h3&gt;
&lt;p&gt;There are several packages that can perform non-linear regression analysis, the function most resembling the approach used by &lt;code&gt;SPSS&lt;/code&gt; is &lt;code&gt;nls&lt;/code&gt; in the default &lt;code&gt;stats&lt;/code&gt; package.&lt;/p&gt;
&lt;p&gt;The easiest way to do this is to first define your function (i.e., the solution) and then fit it using starting values for the parameters.&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;library(rio)
df &amp;lt;- rio::import(&amp;quot;https://github.com/FredHasselman/The-Complex-Systems-Approach-Book/raw/master/assignments/assignment_data/BasicTSA_nonlinreg/GrowthRegression.sav&amp;quot;, setclass = &amp;quot;tbl_df&amp;quot;)

# Create the function for the analytic solution
# Same as SPSS syntax: PRED_=K*Yzero/(Yzero + (K-Yzero) * EXP(-1*(r * Time))).
log.eq &amp;lt;- function(Yzero, r, K, Time) {
    K*Yzero/(Yzero + (K-Yzero) * exp(-1*(r * Time)))
}&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;There is one drawback and you can read about in the help pages:&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;Warning. Do not use nls on artificial “zero-residual” data.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;This means, “do not use it on data generated by a deterministic model which has no residual error”, which is exactly what the time series in this assignment is, it is the output of the logistic flow.&lt;/p&gt;
&lt;p&gt;So, this will give an error:&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;# Fit this function ... gives an error
# The list after &amp;#39;start&amp;#39; provides the initial values
m.log &amp;lt;- nls(Yt ~ log.eq(Yzero, r, K, Time), data = df, start = list(Yzero=.01, r=.01, K=1), trace = TRUE)&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;It is possible to fit these ideal data using package &lt;code&gt;minpack.lm&lt;/code&gt;, which contains function &lt;code&gt;nlsM&lt;/code&gt;.&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;library(minpack.lm)

m.log &amp;lt;- nlsLM(Yt ~ log.eq(Yzero, r, K, Time), data = df, start = list(Yzero = .01, r=.01, K=0.1))

summary(m.log)&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;## 
## Formula: Yt ~ log.eq(Yzero, r, K, Time)
## 
## Parameters:
##        Estimate Std. Error t value Pr(&amp;gt;|t|)    
## Yzero 7.055e-03  8.983e-05   78.53   &amp;lt;2e-16 ***
## r     1.494e-01  3.878e-04  385.18   &amp;lt;2e-16 ***
## K     1.002e+00  4.376e-04 2289.42   &amp;lt;2e-16 ***
## ---
## Signif. codes:  0 &amp;#39;***&amp;#39; 0.001 &amp;#39;**&amp;#39; 0.01 &amp;#39;*&amp;#39; 0.05 &amp;#39;.&amp;#39; 0.1 &amp;#39; &amp;#39; 1
## 
## Residual standard error: 0.002865 on 97 degrees of freedom
## 
## Number of iterations to convergence: 21 
## Achieved convergence tolerance: 1.49e-08&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;In order to look at the model prediction, we use &lt;code&gt;predict()&lt;/code&gt; which is defined for almost all model fitting functions in &lt;code&gt;R&lt;/code&gt;&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;Ypred &amp;lt;- predict(m.log)

plot(ts(df$Yt), col=&amp;quot;gray40&amp;quot;, lwd=5, ylab = (&amp;quot;Yt | Ypred&amp;quot;))
lines(Ypred, col=&amp;quot;gray80&amp;quot;, lwd=2, lty=2)&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;img src=&#34;/project/COVID19/index_files/figure-html/unnamed-chunk-8-1.png&#34; width=&#34;672&#34; /&gt;&lt;/p&gt;
&lt;p&gt;Then we do a polynomial regression using &lt;code&gt;lm&lt;/code&gt;:&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;attach(df)
  df$T1 &amp;lt;- Yt * Time
  df$T2 &amp;lt;- Yt * (Time^2) 
  df$T3 &amp;lt;- Yt * (Time^3) 
  df$T4 &amp;lt;- Yt * (Time^4)
detach(df)

m.poly &amp;lt;- lm(Yt ~ T1 + T2 + T3 + T4, data=df)
summary(m.poly)&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;## 
## Call:
## lm(formula = Yt ~ T1 + T2 + T3 + T4, data = df)
## 
## Residuals:
##        Min         1Q     Median         3Q        Max 
## -0.0117491 -0.0046800 -0.0000683  0.0045719  0.0112732 
## 
## Coefficients:
##               Estimate Std. Error t value Pr(&amp;gt;|t|)    
## (Intercept)  2.113e-02  1.258e-03   16.80   &amp;lt;2e-16 ***
## T1           6.366e-02  7.169e-04   88.80   &amp;lt;2e-16 ***
## T2          -1.497e-03  3.100e-05  -48.28   &amp;lt;2e-16 ***
## T3           1.510e-05  4.425e-07   34.12   &amp;lt;2e-16 ***
## T4          -5.529e-08  2.055e-09  -26.90   &amp;lt;2e-16 ***
## ---
## Signif. codes:  0 &amp;#39;***&amp;#39; 0.001 &amp;#39;**&amp;#39; 0.01 &amp;#39;*&amp;#39; 0.05 &amp;#39;.&amp;#39; 0.1 &amp;#39; &amp;#39; 1
## 
## Residual standard error: 0.005506 on 95 degrees of freedom
## Multiple R-squared:  0.9998, Adjusted R-squared:  0.9998 
## F-statistic: 1.264e+05 on 4 and 95 DF,  p-value: &amp;lt; 2.2e-16&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Then, predict and plot!&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;Ypoly &amp;lt;- predict(m.poly)

plot(ts(Ypoly), col=&amp;quot;blue1&amp;quot;, lwd=2, ylab = (&amp;quot;Ypoly (blue) | Ypred (red)&amp;quot;))
lines(Ypred, col=&amp;quot;red1&amp;quot;, lwd=2)&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;img src=&#34;/project/COVID19/index_files/figure-html/unnamed-chunk-10-1.png&#34; width=&#34;672&#34; /&gt;&lt;/p&gt;
&lt;p&gt;Software packages like SPSS compute an &lt;span class=&#34;math inline&#34;&gt;\(r^2\)&lt;/span&gt; value for non-linear regression models, which doesn’t make a lot of sense if you think about it. Here we van just compare the residual errors:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Polynomial regression: &lt;span class=&#34;math inline&#34;&gt;\(0.005506\)&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;Analytic solution: &lt;span class=&#34;math inline&#34;&gt;\(0.002865\)&lt;/span&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Slightly less residual error for the analytic solution, using less parameters to fit the model (3 vs. 5). &lt;strong&gt;More important:&lt;/strong&gt;, the parameters of the analytic solution have a direct interpretation in terms of growth processes.&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div id=&#34;fitting-analytic-solutions-covid-19-in-the-netherlands&#34; class=&#34;section level1&#34;&gt;
&lt;h1&gt;&lt;strong&gt;Fitting Analytic Solutions: COVID-19 in The Netherlands&lt;/strong&gt;&lt;/h1&gt;
&lt;div id=&#34;get-open-data&#34; class=&#34;section level2&#34;&gt;
&lt;h2&gt;Get Open Data&lt;/h2&gt;
&lt;p&gt;There are lots of open data sets available! Some even come with instructions on how to download and import into R (&lt;a href=&#34;https://www.ecdc.europa.eu/en/publications-data/download-todays-data-geographic-distribution-covid-19-cases-worldwide&#34;&gt;European CDC&lt;/a&gt;).&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;# Import Dutch data from Github account CoronaWatchNL https://github.com/J535D165/CoronaWatchNL
dfNLfatalTOT &amp;lt;- rio::import(&amp;quot;https://raw.githubusercontent.com/J535D165/CoronaWatchNL/master/data/rivm_corona_in_nl_fatalities.csv&amp;quot;)
dfNLhospTOT  &amp;lt;- rio::import(&amp;quot;https://raw.githubusercontent.com/J535D165/CoronaWatchNL/master/data/rivm_corona_in_nl_hosp.csv&amp;quot;)
dfNLcasesTOT &amp;lt;- rio::import(&amp;quot;https://raw.githubusercontent.com/J535D165/CoronaWatchNL/master/data/rivm_corona_in_nl_daily.csv&amp;quot;)

dfNLall &amp;lt;- ldply(list(Fatalities=dfNLfatalTOT,  Hospiltalisations = dfNLhospTOT, Cases = dfNLcasesTOT))

#Take out the year for better display
dfNLall$Datum &amp;lt;- gsub(&amp;quot;(2020-)&amp;quot;,&amp;quot;&amp;quot;,dfNLall$Datum) 
# Make an ordered factor
dfNLall$caseType &amp;lt;- factor(dfNLall$.id, levels = ,labels = c(&amp;quot;Cases Tested Positive&amp;quot;, &amp;quot;Hospitalisations&amp;quot;, &amp;quot;Fatalities&amp;quot;)) 

# EUROPEAN CDC
#download the dataset from the ECDC website to a local temporary file
GET(&amp;quot;https://opendata.ecdc.europa.eu/covid19/casedistribution/csv&amp;quot;, authenticate(&amp;quot;:&amp;quot;, &amp;quot;:&amp;quot;, type=&amp;quot;ntlm&amp;quot;), write_disk(tf &amp;lt;- tempfile(fileext = &amp;quot;.csv&amp;quot;)))&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;## Response [https://opendata.ecdc.europa.eu/covid19/casedistribution/csv/]
##   Date: 2020-04-07 22:10
##   Status: 200
##   Content-Type: application/octet-stream
##   Size: 476 kB
## &amp;lt;ON DISK&amp;gt;  /var/folders/81/ps3s3r7x77bgm7l7n5vm4spr0000gp/T//Rtmp6A0cPB/file86a9670b409b.csv&lt;/code&gt;&lt;/pre&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;#read the Dataset sheet into “R”. The dataset will be called &amp;quot;data&amp;quot;.
data &amp;lt;- read.csv(tf, stringsAsFactors = FALSE)&lt;/code&gt;&lt;/pre&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;ggplot(dfNLall, aes(x=Datum, y=Aantal)) +
  geom_point() +
  theme_bw() +
  facet_wrap(.~.id, scales = &amp;quot;free_y&amp;quot;,ncol = 1) +
  scale_x_discrete(&amp;quot;Date&amp;quot;) +
  scale_y_continuous(&amp;quot;Number of Cases [note different scales]&amp;quot;) +
  labs(caption  = &amp;quot;Data: https://github.com/J535D165/CoronaWatchNL&amp;quot;,
       subtitle = paste0(&amp;quot;COVID-19 in the Netherlands: &amp;quot;,max(dfNLfatalTOT$Datum, na.rm = TRUE))) +
  theme(axis.text.x = element_text(angle = 90, vjust = 0.5))&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;img src=&#34;/project/COVID19/index_files/figure-html/growtData-1.png&#34; width=&#34;672&#34; /&gt;&lt;/p&gt;
&lt;/div&gt;
&lt;div id=&#34;fitting&#34; class=&#34;section level2&#34;&gt;
&lt;h2&gt;Fitting&lt;/h2&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;dfNLfatalTOT$Time &amp;lt;- 1:NROW(dfNLfatalTOT)

# Unrestricted growth
growthUNRes &amp;lt;- function(Y0, r, Time) {
  fpred  &amp;lt;- Y0*exp(r*Time)
  return(fpred)
}
mFatal &amp;lt;- nlsLM(Aantal ~ growthUNRes(Y0, r, Time), data = dfNLfatalTOT, start = list(Y0=1, r=.01))
summary(mFatal)&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;## 
## Formula: Aantal ~ growthUNRes(Y0, r, Time)
## 
## Parameters:
##     Estimate Std. Error t value Pr(&amp;gt;|t|)    
## Y0 28.807678   4.728819   6.092 9.45e-07 ***
## r   0.132566   0.005482  24.184  &amp;lt; 2e-16 ***
## ---
## Signif. codes:  0 &amp;#39;***&amp;#39; 0.001 &amp;#39;**&amp;#39; 0.01 &amp;#39;*&amp;#39; 0.05 &amp;#39;.&amp;#39; 0.1 &amp;#39; &amp;#39; 1
## 
## Residual standard error: 97.12 on 31 degrees of freedom
## 
## Number of iterations to convergence: 16 
## Achieved convergence tolerance: 1.49e-08&lt;/code&gt;&lt;/pre&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;# Logistic growth
growthLogist &amp;lt;- function(K,r,tau,Time){
  fpred  &amp;lt;- K/(1 + exp(-r*(Time - tau)))
  return(fpred)
}
mFatalLog &amp;lt;- nlsLM(Aantal ~ growthLogist(K,r,tau, Time), data = dfNLfatalTOT, start = list(K=5000,r=.01, tau=1))
summary(mFatalLog)&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;## 
## Formula: Aantal ~ growthLogist(K, r, tau, Time)
## 
## Parameters:
##      Estimate Std. Error t value Pr(&amp;gt;|t|)    
## K   2.630e+03  6.187e+01   42.51   &amp;lt;2e-16 ***
## r   2.398e-01  5.334e-03   44.97   &amp;lt;2e-16 ***
## tau 2.785e+01  2.321e-01  120.00   &amp;lt;2e-16 ***
## ---
## Signif. codes:  0 &amp;#39;***&amp;#39; 0.001 &amp;#39;**&amp;#39; 0.01 &amp;#39;*&amp;#39; 0.05 &amp;#39;.&amp;#39; 0.1 &amp;#39; &amp;#39; 1
## 
## Residual standard error: 20.11 on 30 degrees of freedom
## 
## Number of iterations to convergence: 16 
## Achieved convergence tolerance: 1.49e-08&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;div id=&#34;forecasting&#34; class=&#34;section level2&#34;&gt;
&lt;h2&gt;Forecasting&lt;/h2&gt;
&lt;p&gt;After the fit, we can predict&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;dfNLfatalTOT$Datum.f   &amp;lt;- gsub(&amp;quot;(2020-)&amp;quot;,&amp;quot;&amp;quot;,dfNLfatalTOT$Datum) 
dfNLfatalTOT$Pred    &amp;lt;- predict(mFatal)
dfNLfatalTOT$PredLog &amp;lt;- predict(mFatalLog)


# Coefficients
CF   &amp;lt;- coef(mFatalLog)
CFun &amp;lt;- coef(mFatal)

# Forecast
fact &amp;lt;- 2.5
dfForecast &amp;lt;- data.frame(Time  = 1:(NROW(dfNLfatalTOT)*fact),
                         forecast = growthLogist(K = CF[&amp;quot;K&amp;quot;],
                                                 r = CF[&amp;quot;r&amp;quot;],
                                                 tau = CF[&amp;quot;tau&amp;quot;],
                                                 Time = 1:(NROW(dfNLfatalTOT)*fact)))

Time1   &amp;lt;- which(diff(round(dfForecast$forecast[dfForecast$Time&amp;gt;round(CF[&amp;quot;tau&amp;quot;])]))&amp;lt;=1)[1]+round(CF[&amp;quot;tau&amp;quot;])
finDate &amp;lt;- paste(max(lubridate::as_date(dfNLfatalTOT$Datum))+Time1)
finDate &amp;lt;- gsub(&amp;quot;(2020-)&amp;quot;,&amp;quot;&amp;quot;,finDate) 

dfForecastUN &amp;lt;- data.frame(Time  = 1:Time1,
                         forecast = growthUNRes(Y0 = CFun[&amp;quot;Y0&amp;quot;],
                                                r = CFun[&amp;quot;r&amp;quot;],
                                                Time = 1:Time1))&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;div id=&#34;make-a-plot-of-fit-and-forecast&#34; class=&#34;section level2&#34;&gt;
&lt;h2&gt;Make a plot of fit and forecast&lt;/h2&gt;
&lt;p&gt;Use &lt;code&gt;ggplot2&lt;/code&gt;&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;ggplot(dfNLfatalTOT, aes(x=Time, y=Aantal)) +
  geom_vline(xintercept = Time1) +
  geom_point(aes(fill=&amp;quot;Observed&amp;quot;), pch=21, size=3) +
  geom_point(aes(fill=&amp;quot;Predicted: &amp;lt;1 death/day&amp;quot;), x=Time1, y = dfForecast$forecast[Time1], pch=21, colour = &amp;quot;steelblue&amp;quot;, size=3) +
  geom_path(data = dfForecast, aes(x=Time, y=forecast, linetype=&amp;quot;Logistic Growth Forecast&amp;quot;), size=0.3, colour = &amp;quot;black&amp;quot;) +
  geom_path(data = dfForecastUN, aes(x=Time, y=forecast, linetype=&amp;quot;Unrestricted Growth Forecast&amp;quot;), size=0.3, colour = &amp;quot;black&amp;quot;) +
  geom_path(aes(x=Time, y=Pred, colour=paste0(&amp;quot;Unrestricted Growth (r = &amp;quot;,round(CFun[&amp;quot;r&amp;quot;],2),&amp;quot;, Max.Deaths = ??)&amp;quot;)), size=1) +
  geom_path(aes(x=Time, y=PredLog, colour=paste0(&amp;quot;Logistic Growth (r = &amp;quot;,round(CF[&amp;quot;r&amp;quot;],2),&amp;quot;, Max.Deaths = &amp;quot;,round(CF[&amp;quot;K&amp;quot;]), &amp;quot;)&amp;quot;)), size=1) +
  labs(caption  = &amp;quot;Data: https://github.com/J535D165/CoronaWatchNL&amp;quot;,
       subtitle = paste0(&amp;quot;Netherlands: &amp;quot;,max(dfNLfatalTOT$Datum, na.rm = TRUE))) +
  scale_x_continuous(&amp;quot;Date&amp;quot;,
                     breaks = c(dfNLfatalTOT$Time,Time1, 55),
                     labels = c(dfNLfatalTOT$Datum.f,finDate,&amp;quot;1 juno&amp;quot;),
                     limits = c(1,(Time1+4)), expand = c(0.01,0)) +
  scale_y_continuous(&amp;quot;Number of Deaths&amp;quot;, breaks = c(0,500,1000,1500,2000,2500,3000),limits = c(0,3000)) +
  scale_colour_manual(&amp;quot;Nonlinear least squares fit:&amp;quot;,values=c(&amp;quot;steelblue&amp;quot;,&amp;quot;red3&amp;quot;,&amp;quot;grey50&amp;quot;))+
  scale_linetype_manual(&amp;quot;Analytic solution based on fitted values&amp;quot;,values=c(2,3))+
  scale_fill_manual(&amp;quot;Fatalities in The Netherlands&amp;quot;,values=c(&amp;quot;black&amp;quot;,&amp;quot;steelblue&amp;quot;))+
  guides(fill = guide_legend(order = 1), color = guide_legend(order = 2), linetype = guide_legend(order = 3)) +
  theme_bw() +
  theme(axis.text.x     = element_text(angle = 90, vjust = 0.5, hjust = 0),
        legend.position = c(0.25,0.7),
        legend.background =  element_rect(colour = &amp;quot;black&amp;quot;,fill = &amp;quot;white&amp;quot;),
        legend.text = element_text(size=8),
        legend.title = element_text(size=9))&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;img src=&#34;/project/COVID19/index_files/figure-html/makeNLplot-1.png&#34; width=&#34;672&#34; /&gt;&lt;/p&gt;
&lt;/div&gt;
&lt;div id=&#34;global-data&#34; class=&#34;section level2&#34;&gt;
&lt;h2&gt;Global data&lt;/h2&gt;
&lt;p&gt;Coming soon…&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&#34;footnotes&#34;&gt;
&lt;hr /&gt;
&lt;ol&gt;
&lt;li id=&#34;fn1&#34;&gt;&lt;p&gt;Note: For clarity of presentation I am skipping some of the formal language used to describe time series&lt;a href=&#34;#fnref1&#34; class=&#34;footnote-back&#34;&gt;↩&lt;/a&gt;&lt;/p&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;/div&gt;
</description>
    </item>
    
  </channel>
</rss>
